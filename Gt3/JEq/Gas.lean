-- import Gt3.JEq.Basic

-- inductive Ctx.GJEq : ℕ → Ctx → Tm 0 → Tm 0 → Tm 0 → Prop
--     -- Congruence rules
--     | fv {s} {Γ : Ctx} {x : String} {A : Tm 0}
--         (hΓ : GJEq s Γ .unit .null .null)
--         (hx : Ctx.Lookup Γ x A)
--         : GJEq (s + 1) Γ A (Tm.fv x) (Tm.fv x)
--     | univ {s} {Γ : Ctx} {ℓ}
--         : GJEq s Γ .unit .null .null
--         → GJEq (s + 1) Γ (.univ (ℓ + 1)) (.univ ℓ) (.univ ℓ)
--     | empty {s} {Γ : Ctx} {ℓ} : GJEq s Γ .unit .null .null
--       → GJEq (s + 1) Γ (.univ ℓ) .empty .empty
--     | unit {s} {Γ : Ctx} {ℓ} : GJEq s Γ .unit .null .null
--       → GJEq (s + 1) Γ (.univ ℓ) .unit .unit
--     | eqn {s} {Γ : Ctx} {A a a' b b' : Tm 0} {ℓ : ℕ}
--         (ha : GJEq s Γ A a a')
--         (hb : GJEq s Γ A b b')
--         : GJEq (s + 1) Γ (.univ ℓ) (.eqn a b) (.eqn a' b')
--     | pi {s} {Γ : Ctx} {A A' : Tm 0} {B B' : Tm 1} {ℓ m n : ℕ} {L : Finset String}
--         (hA : GJEq s Γ (.univ m) A A')
--         (hB : ∀ x ∉ L, GJEq s (Γ.cons x A) (.univ n) (B.open x) (B'.open x))
--         (hm : m ≤ ℓ) (hn : n ≤ ℓ) (hℓ : 1 ≤ ℓ)
--         : GJEq (s + 1) Γ (.univ ℓ) (.pi A B) (.pi A' B')
--     | abs {s} {Γ : Ctx} {A A' : Tm 0} {B b b' : Tm 1} {t t' : Tm 1} {m : ℕ} {L : Finset String}
--         (hA : GJEq s Γ (.univ m) A A')
--         (hb : ∀ x ∉ L, GJEq s (Γ.cons x A) (B.open x) (b.open x) (b'.open x))
--         : GJEq s Γ (A.pi B) (A.abs b) (A'.abs b')
--     | app {s} {Γ : Ctx} {A : Tm 0} {B : Tm 1} {f f' a a' Ba : Tm 0} {n : ℕ}
--         (hf : GJEq s Γ (A.pi B) f f')
--         (ha : GJEq s Γ A a a')
--         (hBa : GJEq s Γ (.univ n) (B.lst a) Ba)
--         : GJEq s Γ Ba (f.app a) (f'.app a')
--     -- Context well-formedness
--     | nil_ok {s} : GJEq s .nil .unit .null .null
--     | cons_ok {s} {Γ : Ctx} {x : String} {A : Tm 0} {ℓ}
--         (hΓ : GJEq s Γ .unit .null .null)
--         (hx : x ∉ Γ.dv)
--         (hA : GJEq s Γ (.univ ℓ) A A)
--         : GJEq (s + 1) (Γ.cons x A) .unit .null .null
--     -- Reduction
--     | beta_app {s} {Γ : Ctx} {A : Tm 0} {B b : Tm 1} {a ba Ba : Tm 0}
--         (hf : GJEq s Γ (A.pi B) (A.abs b) (A.abs b))
--         (ha : GJEq s Γ A a a)
--         (hba : GJEq s Γ Ba (b.lst a) ba)
--         : GJEq (s + 1) Γ Ba (.app (A.abs b) a) ba
--     -- Reflexivity and extensionality
--     | eqn_rfl {s} {Γ : Ctx} {A a b: Tm 0}
--         : GJEq s Γ A a b
--         → GJEq (s + 1) Γ (.univ 0) (.eqn a b) .unit
--     | eqn_ext {s} {Γ : Ctx} {A a b : Tm 0}
--         : GJEq s Γ A a a → GJEq s Γ A b b → GJEq s Γ (.univ 0) (.eqn a b) .unit
--         → GJEq (s + 1) Γ A a b
--     -- Casting
--     | cast_level {s} {Γ : Ctx} {A A' : Tm 0} {ℓ : ℕ}
--         (hA : GJEq s Γ (.univ ℓ) A A')
--         : GJEq (s + 1) Γ (.univ (ℓ + 1)) A A'
--     | cast {s} {Γ : Ctx} {A A' a a' : Tm 0} {ℓ : ℕ}
--         (hA : GJEq s Γ (.univ ℓ) A A')
--         (ha : GJEq s Γ A a a')
--         : GJEq (s + 1) Γ A' a a'
--     -- Symmetry and transitivity
--     | symm {s} {Γ : Ctx} {A a b : Tm 0} : GJEq s Γ A a b → GJEq (s + 1) Γ A b a
--     | trans {s} {Γ : Ctx} {A a b c : Tm 0}
--         (hab : GJEq s Γ A a b)
--         (hbc : GJEq s Γ A b c)
--         : GJEq (s + 1) Γ A a c

-- theorem Ctx.GJEq.toSucc {s} {Γ A a b}
--   (hab : Ctx.GJEq s Γ A a b) : Ctx.GJEq (s + 1) Γ A a b := by induction hab with
--   | cast_level => apply cast_level ; assumption
--   | cast => apply cast <;> assumption
--   | symm => apply symm; assumption
--   | trans => apply trans <;> assumption
--   | _ => constructor <;> intros <;> apply_assumption <;> assumption

-- theorem Ctx.GJEq.mono {s t} (h : s ≤ t) {Γ A a b}
--   (hab : Ctx.GJEq s Γ A a b) : Ctx.GJEq t Γ A a b := by
--   induction h with
--   | refl => assumption
--   | step hst ih => exact ih.toSucc

-- theorem Ctx.GJeq.erase {s} {Γ A a b}
--   (hab : GJEq s Γ A a b) : JEq Γ A a b := by induction hab with
--   | cast_level => apply JEq.cast_level; assumption
--   | symm => apply JEq.symm; assumption
--   | trans => apply JEq.trans <;> assumption
--   | cast => apply JEq.cast <;> assumption
--   | _ => constructor <;> assumption
