import Gt3.Tree.WithLeaf
import Gt3.Utils.Tuple

namespace Gt3

open NumChildren BinderList HasChildren

inductive WTree (α : Type _) [NumChildren α] : (numLabels : ℕ) → Type _
  | jump
    (tag : α) {numLabels : ℕ}
    (targets : Fin (numChildren tag) → Fin (numLabels))
    : WTree α numLabels
  | block
    {numLabels numTargets : ℕ}
    (terminator : WTree α (numLabels + numTargets))
    (subtrees : Fin numTargets → WTree α (numLabels + numTargets))
    : WTree α numLabels

-- Equivalence on WTrees is just the equivalence generated by
  -- permuting blocks
  -- merging blocks

inductive ATree (α : Type _) [NumChildren α] : (numLabels : ℕ) → Type _
  | jump
    (tag : α) {numTargets numLabels : ℕ}
    (targets : Fin (numChildren tag) → Fin numLabels)
    : ATree α numLabels
  | block
    {numLabels numTargets : ℕ}
    (terminator : ATree α (numLabels + numTargets))
    (subtrees : Fin numTargets → ATree α (numLabels + numTargets))
    : ATree α numLabels

-- Likewise for ATrees...

inductive WATree (α : Type _) [NumChildren α] : (numLabels : ℕ) → Type _
  | jump
    (tag : α) {numTargets numLabels : ℕ}
    (targets : Fin (numChildren tag) → Fin numLabels)
    : WATree α numLabels
  | cyclic
    {numLabels numTargets : ℕ}
    (terminator : WTree α (numLabels + numTargets))
    (subtrees : Fin numTargets → WTree α (numLabels + numTargets))
    : WATree α numLabels
  | acyclic
    {numLabels numTargets : ℕ}
    (terminator : ATree α (numLabels + numTargets))
    (subtrees : Fin numTargets → ATree α (numLabels + numTargets))
    : WATree α numLabels

-- And WATrees...

-- TODO: factor out flat things to separate repo

inductive FWTree (α : Type _) [NumChildren α] : (numLabels : ℕ) → Type _
  | node
    (tag : α) {numTargets numLabels : ℕ}
    (targets : Fin (numChildren tag) → Fin (numLabels + numTargets))
    (subtrees : Fin numTargets → FWTree α (numLabels + numTargets)) : FWTree α numLabels

inductive FATree (α : Type _) [NumChildren α] : (numLabels : ℕ) → Type _
  | node
    (tag : α) {numTargets numLabels : ℕ}
    (targets : Fin (numChildren tag) → Fin numLabels)
    (subtrees : Fin (numChildren tag) → FATree α numLabels) : FATree α numLabels

inductive FWATree (α : Type _) [NumChildren α] : (numLabels : ℕ) → Type _
  | cyclic
    (tag : α) {numTargets numLabels : ℕ}
    (targets : Fin (numChildren tag) → Fin (numLabels + numTargets))
    (subtrees : Fin (numChildren tag) → FWTree α (numLabels + numTargets)) : FWATree α numLabels
  | acyclic
    (tag : α) {numTargets numLabels : ℕ}
    (targets : Fin (numChildren tag) → Fin numLabels)
    (subtrees : Fin (numChildren tag) → FATree α numLabels) : FWATree α numLabels

def FWTree.mapLabels {α : Type _} [NumChildren α]
  {numLabels₁ numLabels₂ : ℕ}
  (f : Fin numLabels₁ → Fin numLabels₂)
  : FWTree α numLabels₁ → FWTree α numLabels₂
  | FWTree.node tag targets subtrees =>
    FWTree.node tag (mapFinAdd f id ∘ targets) (fun i => (subtrees i).mapLabels (mapFinAdd f id))

def FWTree.childIx {numTargets numLabels : ℕ} (i : Fin (numLabels + numTargets))
  : WithLeaf (Fin numTargets) (Fin numLabels)
  := Fin.append .leaf .branch i

def FWTree.childLabel? {numTargets numLabels : ℕ} (i : Fin (numLabels + numTargets))
  : Option (Fin numLabels)
  := Fin.append .some (fun _ => none) i

def FWTree.childTarget? {numTargets numLabels : ℕ} (i : Fin (numLabels + numTargets))
  : Option (Fin numTargets)
  := Fin.append (fun _ => none) .some i

def FWTree.tag {α : Type _} [NumChildren α] {numLabels : ℕ} : FWTree α numLabels → α
  | FWTree.node tag _ _ => tag

def FWTree.numTargets {α : Type _} [NumChildren α]
  {numLabels : ℕ} : FWTree α numLabels → ℕ
  | .node (numTargets := numTargets) .. => numTargets

def FWTree.targets {α : Type _} [NumChildren α]
  {numLabels : ℕ}
  (t : FWTree α numLabels) : Fin (numChildren t.tag) → Fin (numLabels + t.numTargets)
  := match t with
  | FWTree.node _ targets _ => targets

def FWTree.getChildIx {α : Type _} [NumChildren α]
  {numLabels : ℕ}
  (t : FWTree α numLabels) (i : Fin (numChildren t.tag))
  : WithLeaf (Fin (t.numTargets)) (Fin numLabels)
  := FWTree.childIx (t.targets i)

def FWTree.subtrees {α : Type _} [NumChildren α]
  {numLabels : ℕ}
  (t : FWTree α numLabels) : Fin (t.numTargets) → FWTree α (numLabels + t.numTargets)
  := match t with
  | FWTree.node _ _ subtrees => subtrees

def FWTree.children {α : Type _} [NumChildren α]
  {numLabels : ℕ}
  (t : FWTree α numLabels) (i : Fin (numChildren t.tag))
  : WithLeaf (FWTree α (numLabels + t.numTargets)) (Fin numLabels)
  := (t.getChildIx i).mapBranch t.subtrees

inductive FWTree.Permutation {α : Type _} [NumChildren α]
  : ∀ {numLabels : ℕ},
    (Fin numLabels → Fin numLabels) → FWTree α numLabels → FWTree α numLabels → Type _
  | node
    {numLabels : ℕ}
    (σ : Fin numLabels → Fin numLabels)
    (tag : α)
    {numTargets : ℕ}
    {targets₁ targets₂ : Fin (numChildren tag) → Fin (numLabels + numTargets)}
    {subtrees₁ subtrees₂ : Fin numTargets → FWTree α (numLabels + numTargets)}
    (targets : Option.map σ ∘ childLabel? ∘ targets₁ = childLabel? ∘ targets₂)
    (ρ : Fin numTargets → Fin numTargets)
    (subtrees :
      ∀ i, ∀ t₁ ∈ childTarget? (targets₁ i), ∀ t₂ ∈ childTarget? (targets₂ i),
        FWTree.Permutation (mapFinAdd σ ρ) (subtrees₁ t₁) (subtrees₂ t₂)
    )
    : FWTree.Permutation σ
      (FWTree.node tag targets₁ subtrees₁)
      (FWTree.node tag targets₂ subtrees₂)

def FWTree.Permutation.cast {α : Type _} [NumChildren α]
  {numLabels : ℕ} {σ σ' : Fin numLabels → Fin numLabels}
  {t₁ t₂ t₁' t₂' : FWTree α numLabels}
  (h : FWTree.Permutation σ t₁ t₂)
  (hσ : σ = σ') (ht₁ : t₁ = t₁') (ht₂ : t₂ = t₂') : FWTree.Permutation σ' t₁' t₂'
  := hσ ▸ ht₁ ▸ ht₂ ▸ h

def FWTree.Permutation.refl {α : Type _} [NumChildren α]
  {numLabels : ℕ}
  : (t : FWTree α numLabels) → FWTree.Permutation id t t
  | .node tag targets subtrees =>
    .node id tag (by simp) id (fun i t₁ ht₁ t₂ ht₂ =>
    (refl (subtrees t₁)).cast (by simp) rfl (by congr; apply Option.mem_unique <;> assumption))

inductive FWTree.Shuffle {α : Type _} [NumChildren α]
  : ∀ {numLabels₁ numLabels₂ : ℕ},
    (Fin numLabels₁ → Fin numLabels₂) → FWTree α numLabels₁ → FWTree α numLabels₂ → Type _
  | node
    {numLabels₁ numLabels₂ : ℕ}
    (σ : Fin numLabels₁ → Fin numLabels₂)
    (tag : α)
    {numTargets₁ numTargets₂ : ℕ}
    {targets₁ : Fin (numChildren tag) → Fin (numLabels₁ + numTargets₁)}
    {subtrees₁ : Fin numTargets₁ → FWTree α (numLabels₁ + numTargets₁)}
    {targets₂ : Fin (numChildren tag) → Fin (numLabels₂ + numTargets₂)}
    {subtrees₂ : Fin numTargets₂ → FWTree α (numLabels₂ + numTargets₂)}
    (targets : Option.map σ ∘ childLabel? ∘ targets₁ = childLabel? ∘ targets₂)
    (ρ : Fin numTargets₁ → Fin numTargets₂)
    (subtrees :
      ∀ i, ∀ t₁ ∈ childTarget? (targets₁ i), ∀ t₂ ∈ childTarget? (targets₂ i),
        FWTree.Shuffle (mapFinAdd σ ρ) (subtrees₁ t₁) (subtrees₂ t₂)
    )
    : FWTree.Shuffle σ
      (FWTree.node tag targets₁ subtrees₁)
      (FWTree.node tag targets₂ subtrees₂)

def FWTree.Permutation.toShuffle {α : Type _} [NumChildren α]
  {numLabels : ℕ}
  {σ : Fin numLabels → Fin numLabels}
  {t₁ t₂ : FWTree α numLabels}
  : FWTree.Permutation σ t₁ t₂ → FWTree.Shuffle σ t₁ t₂
  | .node σ tag targets ρ subtrees =>
    .node σ tag targets ρ (fun i t₁ ht₁ t₂ ht₂ => (subtrees i t₁ ht₁ t₂ ht₂).toShuffle)

def FWTree.Shuffle.refl {α : Type _} [NumChildren α]
  {numLabels : ℕ}
  (t : FWTree α numLabels) : FWTree.Shuffle id t t
  := (Permutation.refl t).toShuffle

-- TODO: shuffle cast

-- TODO: shuffle symm, which is actually pretty complicated due to pseudo-inversion

-- TODO: shuffle trans, easier, hopefully

-- TODO: shuffle induces a setoid, but not _quite_ the one we want, because we also want to...

-- TODO: re-associate! let's call reassoc + shuffle = ashuffle

-- TODO: FWTrees map to PFCotrees, and hence to FCotrees

-- TODO: the ashuffle setoid is _precisely_ equality of the map to cotrees

-- TODO: PFCotrees map to FWTrees via dominance relation...
-- or yannow we can just copy the entry block...

-- TODO: implying a bijection up to setoids, and giving us an induction principle on
-- PFCotrees and hence FCotrees

-- TODO: in fact, the map FWTree -> PFCotree is surjective on dominance-ordered PFCotrees...

-- TODO: ATree injectively maps to WATree (obviously)

-- TODO: permutations / shuffles / ashuffles of ATree
-- ; ATree => WATree => FWTree is permutation / shuffle preserving

-- TODO: ATree maps to Tree

-- TODO: ATree shuffle corresponds precisely to equal trees

-- TODO: WATree injectively maps to FWTree by mapping acyclic nodes to cyclic nodes; so...
  -- ATree injectively maps to FWTree

end Gt3
